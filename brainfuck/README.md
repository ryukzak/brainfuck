# Brainfuck. Транслятор и модель

- Преподавателя ПИиКТ.
- `brainfuck | bf | harv | hw | instr | struct | stream | port | -`

Примечания:

- Данный проект имеет избыточное количество комментариев (к примеру схемы продублированы для удобства читателя).
- Данный проект предпочитает простоту элегантности, так как является учебным примером. Если можно написать без синтаксического сахара -- лучше без него.
- MR приветствуются, но должны учитывать вышесказанное.
- Данный проект не является обязательным шаблоном и вы можете использовать другую структуру. При этом нагромождения модулей и классов следует избегать.
- Данный проект не может претендовать на высокий балл т.к.:
    - плохие тесты (только интеграционные);
    - проигнорированы классные фишки python 3.6+ (типизация);
    - простой вариант;
    - плохой CLI (всё прибито гвоздями, нет помощи, нет управления уровнем журналов);
    - как минимум одна глупость в работе ControlUnit (умышленно сохранена).
- Указанный выше вариант -- частично вымышленный.

## Язык программирования

``` ebnf
program ::= term

term ::= symbol
       | comment
       | term term
       | "[" term "]"

symbol ::= ">" | "<" | "+" | "-" | "." | ","

comment ::= <any symbols except: "><+-.,[]">
```

Код выполняется последовательно. Операции:

- `+` -- увеличить значение в текущей ячейке на 1
- `-` -- уменьшить значение в текущей ячейке на 1
- `>` -- перейти к следующей ячейке
- `<` -- перейти к предыдущей ячейке
- `.` -- напечатать значение из текущей ячейки (символ)
- `,` -- ввести извне значение и сохранить в текущей ячейке (символ)
- `[` -- если значение текущей ячейки ноль, перейти вперёд по тексту программы на символ, следующий за соответствующей `]` (с учётом вложенности)
- `]` -- если значение текущей ячейки не нуль, перейти назад по тексту программы на символ `[` (с учётом вложенности)

Любые другие символы трактуются как комментарии.

## Система команд

Особенности процессора:

- Машинное слово -- 8 бит, знаковое.
- Память данных:
    - адресуется через регистр `data_address` (может быть только инкрементирован или декрементирован);
    - может быть записана:
        - из аккумулятора `acc` после инкремента/декремента;
        - с порта ввода;
    - может быть прочитана в аккумулятор `acc`.
- Регистр аккумулятора: `acc`:
    - может быть подан на вывод;
    - используется как флаг (сравнение с 0);
    - см. память данных.
- Ввод-вывод -- порты ввода/вывода, токенизирован, символьный.
- `program_counter` -- счётчик команд:
    - инкрементируется после каждой инструкции или перезаписывается инструкцией перехода.

### Набор инструкции

| Syntax | Mnemonic     | Кол-во тактов | Comment                          |
|:-------|:-------------|---------------|:---------------------------------|
| `>`    | right        | 1             | см. язык                         |
| `<`    | left         | 1             | см. язык                         |
| `+`    | increment    | 2             | см. язык                         |
| `-`    | decrement    | 2             | см. язык                         |
| `.`    | print        | 2             | см. язык                         |
| `,`    | input        | 2             | см. язык                         |
|        | jmp `<addr>` | 1             | безусловный переход              |
|        | jz `<addr>`  | 2             | переход, если в текущей ячейке 0 |
|        | halt         | 0             | остановка                        |

### Кодирование инструкций

- Машинный код сериализуется в список JSON.
- Один элемент списка, одна инструкция.
- Индекс списка -- адрес инструкции. Используется для команд перехода.

Пример:

```json
[
    {
        "opcode": "jz",
        "arg": 5,
        "term": [
            1,
            5,
            "]"
        ]
    }
]
```

где:

- `opcode` -- строка с кодом операции;
- `arg` -- аргумент (может отсутствовать);
- `term` -- информация о связанном месте в исходном коде (если есть).

Типы данные в модуле [isa](./isa.py), где:

- `Opcode` -- перечисление кодов операций;
- `Term` -- структура для описания значимого фрагмента кода исходной программы.

## Транслятор

Интерфейс командной строки: `translator.py <input_file> <target_file>"`

Реализовано в модуле: [translator](./translator.py)

Этапы трансляции (функция `translate`):

1. Трансформирование текста в последовательность значимых термов.
2. Проверка корректности программы (парность квадратных скобок).
3. Генерация машинного кода.

Правила генерации машинного кода:

- один символ языка -- одна инструкция;
- для команд, одназначно соответствующих инструкциям -- прямое отображение;
- для циклов с соблюдением парности (многоточие -- произвольный код):

    | Номер команды/инструкции | Программа | Машинный код |
    |:-------------------------|:----------|:-------------|
    | n                        | `[`       | `JZ (k+1)`   |
    | ...                      | ...       | ...          |
    | k                        | `]`       | `JMP n`      |
    | k+1                      | ...       | ...          |

## Модель процессора

Реализовано в модуле: [machine](./machine.py).

### DataPath

``` text
                     +--------------+  addr   +--------+
               +---->| data_address |---+---->|  data  |
               |     +--------------+   |     | memory |
           +-------+                    |     |        |
    sel -->|  MUX  |         +----------+     |        |
           +-------+         |                |        |
            ^     ^          |                |        |
            |     |          |        data_in |        | data_out
            |     +---(+1)---+          +---->|        |-----+
            |                |          |     |        |     |
            +---------(-1)---+          |  oe |        |     |
                                        | --->|        |     |
                                        |     |        |     |
                                        |  wr |        |     |
                                        | --->|        |     |
                                        |     +--------+     |
                                        |                    v
                                    +--------+     latch  +-----+
                          sel ----> |  MUX   |    ------->| acc |
                                    +--------+            +-----+
                                     ^   ^  ^                |
                                     |   |  |                +---(==0)---> zero
                                     |   |  |                |
                                     |   |  +---(+1)---------+
                                     |   |                   |
                                     |   +------(-1)---------+
                                     |                       |
            input -------------------+                       +---------> output
```

Реализован в классе `DataPath`.

- `data_memory` -- однопортовая, по этому либо читаем, либо пишем.
- `input` -- вызовет остановку процесса моделирования, если буфер входных значений закончился.

Сигналы (обрабатываются за один такт, реализованы в виде методов класса):

- `latch_data_addr` -- защёлкнуть выбранное значение в `data_addr`;
- `latch_acc` -- защёлкнуть в аккумулятор выход памяти данных;
- `output` -- записать аккумулятор в порт вывода (обработка на python);
- `wr` -- записать выбранное значение в память:
    - инкрементированное;
    - декрементированное;
    - с порта ввода (обработка на python).

Флаги:

- `zero` -- отражает наличие нулевого значения в аккумуляторе.

### ControlUnit

``` text
   +------------------(+1)-------+
   |                             |
   |   +-----+                   |
   +-->|     |     +---------+   |    +---------+
       | MUX |---->| program |---+--->| program |
   +-->|     |     | counter |        | memory  |
   |   +-----+     +---------+        +---------+
   |                                      |
   |                                      | current instruction
   +---------------(select-arg)-----------+
                                          |      +---------+
                                          |      |  step   |
                                          |  +---| counter |
                                          |  |   +---------+
                                          v  v        ^
                                  +-------------+     |
                                  | instruction |-----+
                      +---------->| decoder     |
                      |           +-------------+
                      |                   |
                      |                   | signals
                      |                   v
                      |    zero     +----------+
                      +-------------|          |
                                    | DataPath |
                     input -------->|          |----------> output
                                    +----------+

```

Реализован в классе `ControlUnit`.

- Hardwired (реализовано полностью на python).
- Моделирование на уровне инструкций.
- Трансляция инструкции в последовательность (0-2 такта) сигналов: `decode_and_execute_instruction`.
- `step_counter` необходим для многотактовых команд:
    - в классе `ControlUnit` отсутствует, т.к. моделирование производится на уровне инструкций.

Сигнал:

- `latch_program_couter` -- сигнал для обновления счётчика команд в ControlUnit.

Особенности работы модели:

- Для журнала состояний процессора используется стандартный модуль logging.
- Количество инструкция для моделирования ограничено hardcoded константой.
- Остановка моделирования осуществляется при помощи исключений:
    - `EOFError` -- если нет данных для чтения из порта ввода вывода;
    - `StopIteration` -- если выполнена инструкция `halt`.
- Управление симуляцией реализовано в функции `simultate`.

## Апробация

В качестве тестов использовано два алгоритма:

1. [hello world](examples/hello.bf).
2. [cat](examples/hello.bf) -- программа `cat`, повторяем ввод на выводе.

Интеграционные тесты реализованы тут: [integration_test](./integration_test.py)

CI:

``` yaml
lab3-example:
  stage: test
  image:
    name: python-tools
    entrypoint: [""]
  script:
    - cd src/brainfuck
    - python3-coverage run -m pytest --verbose
    - find . -type f -name "*.py" | xargs -t python3-coverage report
    - find . -type f -name "*.py" | xargs -t pep8 --ignore=E501
    - find . -type f -name "*.py" | xargs -t pylint
```

где:

- `python3-coverage` -- формирования отчёта о уровне покрытия исходного кода.
- `pytest` -- утилита для запуска тестов.
- `pep8` -- утилита для проверки форматирования кода. `E501` (длина строк) отключено, но не следует этим злоупотреблять.
- `pylint` -- утилита для проверки качества кода. Некоторые правила отключены в отдельных модулях с целью упрощения кода.
- Docker image `python-tools` включает в себя все перечисленные утилиты. Его конфигурация: [Dockerfile](./Dockerfile).

Пример использования и журнал работы процессора на примере `cat`:

``` console
> cd src/brainfuck
> cat examples/foo_input.txt
foo
> cat examples/cat.bf 
,[.,]
> ./translator.py examples/cat.bf target.out
source LoC: 1 code instr: 6
> cat target.out 
[
    {
        "opcode": "input",
        "term": [
            1,
            1,
            ","
        ]
    },
    {
        "opcode": "jz",
        "arg": 5,
        "term": [
            1,
            2,
            "["
        ]
    },
    {
        "opcode": "print",
        "term": [
            1,
            3,
            "."
        ]
    },
    {
        "opcode": "input",
        "term": [
            1,
            4,
            ","
        ]
    },
    {
        "opcode": "jmp",
        "arg": 1,
        "term": [
            1,
            5,
            "]"
        ]
    },
    {
        "opcode": "halt"
    }
]
> ./machine.py target.out examples/foo_input.txt
DEBUG:root:{TICK: 0, PC: 0, ADDR: 0, OUT: 0, ACC: 0} input  (',' @ 1:1)
DEBUG:root:input: 'f'
DEBUG:root:{TICK: 2, PC: 1, ADDR: 0, OUT: 102, ACC: 0} jz 5 ('[' @ 1:2)
DEBUG:root:{TICK: 4, PC: 2, ADDR: 0, OUT: 102, ACC: 102} print  ('.' @ 1:3)
DEBUG:root:output: '' << 'f'
DEBUG:root:{TICK: 6, PC: 3, ADDR: 0, OUT: 102, ACC: 102} input  (',' @ 1:4)
DEBUG:root:input: 'o'
DEBUG:root:{TICK: 8, PC: 4, ADDR: 0, OUT: 111, ACC: 102} jmp 1 (']' @ 1:5)
DEBUG:root:{TICK: 9, PC: 1, ADDR: 0, OUT: 111, ACC: 102} jz 5 ('[' @ 1:2)
DEBUG:root:{TICK: 11, PC: 2, ADDR: 0, OUT: 111, ACC: 111} print  ('.' @ 1:3)
DEBUG:root:output: 'f' << 'o'
DEBUG:root:{TICK: 13, PC: 3, ADDR: 0, OUT: 111, ACC: 111} input  (',' @ 1:4)
DEBUG:root:input: 'o'
DEBUG:root:{TICK: 15, PC: 4, ADDR: 0, OUT: 111, ACC: 111} jmp 1 (']' @ 1:5)
DEBUG:root:{TICK: 16, PC: 1, ADDR: 0, OUT: 111, ACC: 111} jz 5 ('[' @ 1:2)
DEBUG:root:{TICK: 18, PC: 2, ADDR: 0, OUT: 111, ACC: 111} print  ('.' @ 1:3)
DEBUG:root:output: 'fo' << 'o'
DEBUG:root:{TICK: 20, PC: 3, ADDR: 0, OUT: 111, ACC: 111} input  (',' @ 1:4)
DEBUG:root:input: '\n'
DEBUG:root:{TICK: 22, PC: 4, ADDR: 0, OUT: 10, ACC: 111} jmp 1 (']' @ 1:5)
DEBUG:root:{TICK: 23, PC: 1, ADDR: 0, OUT: 10, ACC: 111} jz 5 ('[' @ 1:2)
DEBUG:root:{TICK: 25, PC: 2, ADDR: 0, OUT: 10, ACC: 10} print  ('.' @ 1:3)
DEBUG:root:output: 'foo' << '\n'
DEBUG:root:{TICK: 27, PC: 3, ADDR: 0, OUT: 10, ACC: 10} input  (',' @ 1:4)
WARNING:root:Input buffer is empty!
INFO:root:output_buffer: 'foo\n'
foo

instr_counter:  15 ticks: 28
```

| ФИО           | алг.  | LoC       | code байт | code инстр. | инстр. | такт. | вариант |
|---------------|-------|-----------|-----------|-------------|--------|-------|---------|
| Преподавателя | hello | ...       | -         | ...         | ...    | ...   | ...     |
| Преподавателя | cat   | 1         | -         | 6           | 15     | 28    | ...     |
